<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>üèÆ TEAM DATA SCIENCE R&D MASAN ‚Äî Ch√∫c M·ª´ng NƒÉm M·ªõi 2026 üèÆ</title>
<link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Great+Vibes&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: radial-gradient(ellipse at 50% 40%, #3a0a0a 0%, #1e0000 45%, #0a0000 100%);
    cursor: grab;
    font-family: 'Dancing Script', cursive;
  }
  body:active { cursor: grabbing; }
  canvas { display: block; }

  /* ===== Warm T·∫øt ambient background glow ===== */
  #ambientGlow {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 0;
    background:
      radial-gradient(ellipse 600px 500px at 10% 20%, rgba(180,30,0,0.12) 0%, transparent 70%),
      radial-gradient(ellipse 500px 400px at 90% 15%, rgba(200,50,0,0.10) 0%, transparent 70%),
      radial-gradient(ellipse 400px 350px at 85% 80%, rgba(180,40,0,0.08) 0%, transparent 70%),
      radial-gradient(ellipse 450px 400px at 15% 85%, rgba(200,60,0,0.09) 0%, transparent 70%),
      radial-gradient(ellipse 800px 600px at 50% 50%, rgba(120,10,0,0.15) 0%, transparent 60%);
  }

  /* Subtle vignette for depth */
  #vignette {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 1;
    background: radial-gradient(ellipse at 50% 45%, transparent 40%, rgba(5,0,0,0.5) 100%);
  }

  #petalCanvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 10;
  }

  #hint {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    color: rgba(255,215,0,0.7);
    font-family: 'Dancing Script', cursive;
    font-size: 15px;
    pointer-events: none;
    animation: fadeHint 6s ease-in-out forwards;
    text-shadow: 0 0 20px rgba(255,180,0,0.5);
    white-space: nowrap;
    z-index: 20;
  }
  @keyframes fadeHint {
    0% { opacity: 0; transform: translateX(-50%) translateY(10px); }
    15% { opacity: 1; transform: translateX(-50%) translateY(0); }
    75% { opacity: 1; }
    100% { opacity: 0; }
  }

  /* ===== Greeting header ===== */
  #greeting {
    position: fixed;
    top: 4%;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
    z-index: 20;
    pointer-events: none;
    width: 90%;
  }
  #greeting .team-name {
    font-family: 'Playfair Display', serif;
    font-size: clamp(14px, 2.8vw, 26px);
    color: #ffd700;
    letter-spacing: 4px;
    text-transform: uppercase;
    text-shadow: 0 0 20px rgba(255,215,0,0.5), 0 0 40px rgba(255,150,0,0.3);
    opacity: 0;
    animation: fadeInDown 1.2s ease forwards 0.3s;
    margin-bottom: 6px;
  }
  #greeting h1 {
    font-family: 'Great Vibes', 'Dancing Script', cursive;
    font-size: clamp(26px, 5vw, 54px);
    color: #ff3333;
    text-shadow: 0 0 30px rgba(255,50,0,0.6), 0 0 60px rgba(255,200,0,0.3);
    animation: glowText 3s ease-in-out infinite alternate;
    opacity: 0;
    animation: glowText 3s ease-in-out infinite alternate, fadeInDown 1.2s ease forwards 0.8s;
  }
  #greeting .sub {
    font-family: 'Dancing Script', cursive;
    font-size: clamp(13px, 2.2vw, 20px);
    color: #ffb347;
    margin-top: 6px;
    text-shadow: 0 0 15px rgba(255,180,0,0.4);
    opacity: 0;
    animation: fadeInDown 1.2s ease forwards 1.4s;
  }
  @keyframes glowText {
    0% { text-shadow: 0 0 30px rgba(255,50,0,0.6), 0 0 60px rgba(255,200,0,0.3); opacity:1; }
    100% { text-shadow: 0 0 50px rgba(255,50,0,0.9), 0 0 80px rgba(255,220,0,0.5); opacity:1; }
  }
  @keyframes fadeInDown {
    0% { opacity: 0; transform: translateY(-15px); }
    100% { opacity: 1; transform: translateY(0); }
  }

  #musicControl {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 48px;
    height: 48px;
    background: rgba(255, 180, 0, 0.15);
    border: 2px solid rgba(255, 215, 0, 0.4);
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 22px;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    z-index: 1000;
  }
  #musicControl:hover {
    background: rgba(255, 180, 0, 0.35);
    border-color: rgba(255, 215, 0, 0.8);
    transform: scale(1.1);
  }
  #musicControl.playing {
    animation: pulse 2s ease-in-out infinite;
  }
  @keyframes pulse {
    0%, 100% { box-shadow: 0 0 15px rgba(255, 150, 0, 0.3); }
    50% { box-shadow: 0 0 30px rgba(255, 150, 0, 0.6); }
  }
</style>
</head>
<body>

<!-- Warm ambient background layers -->
<div id="ambientGlow"></div>
<div id="vignette"></div>

<div id="greeting">
  <div class="team-name">‚ú¶ Team Data Science R&D ‚Äî Masan ‚ú¶</div>
  <h1>üèÆ Ch√∫c M·ª´ng NƒÉm M·ªõi 2026 üèÆ</h1>
  <div class="sub">V·∫°n S·ª± Nh∆∞ √ù ‚Ä¢ An Khang Th·ªãnh V∆∞·ª£ng ‚Ä¢ T·∫•n T√†i T·∫•n L·ªôc</div>
</div>

<div id="hint">‚ú® K√©o chu·ªôt ƒë·ªÉ xoay ƒë√®n l·ªìng ‚Ä¢ Cu·ªôn ƒë·ªÉ zoom ‚ú®</div>
<div id="musicControl" class="playing" title="Click ƒë·ªÉ b·∫≠t/t·∫Øt nh·∫°c">üéµ</div>

<canvas id="petalCanvas"></canvas>

<audio id="bgMusic" loop autoplay>
  <source src="van_su_nhu_y.mp3" type="audio/mpeg">
</audio>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================================
// CONFIG ‚Äî ƒê√àN L·ªíNG T·∫æT 2026 ‚Äî TEAM DATA R&D MASAN
// ============================================================
const CONFIG = {
  lanternParticles: 12000,
  lanternScale: 10,
  particleSizeMin: 0.05,
  particleSizeMax: 0.20,
  pulseSpeed: 1.4,
  pulseMagnitude: 0.035,

  // Tassel particles
  tasselParticles: 1500,

  disks: [
    {
      radiusInner: 7,
      radiusOuter: 11,
      tiltX: 0.12,
      yOffset: -8,
      speed: 0.22,
      direction: 1,
      particleCount: 350,
      texts: [
        'üèÆ T√¢n Xu√¢n üèÆ', 'Ph√∫c L·ªôc Th·ªç', 'üå∏ V·∫°n S·ª± Nh∆∞ √ù üå∏', 'An Khang',
        'üèÆ Ph√°t T√†i üèÆ', 'Data Science', 'H·∫°nh Ph√∫c', 'üå∏ B√¨nh An üå∏',
        'May M·∫Øn', 'Masan Team', 'üèÆ ƒê·∫Øc L·ªôc üèÆ', 'Data Science',
      ],
      textSize: 1.3,
      textColor: '#ffd700',
      dustColor: 0xffd700,
      dustOpacity: 0.45,
    },
    {
      radiusInner: 10,
      radiusOuter: 14,
      tiltX: 0.10,
      yOffset: -9,
      speed: 0.14,
      direction: -1,
      particleCount: 500,
      texts: [
        '‚òÖ Ch√∫c M·ª´ng NƒÉm M·ªõi 2026 ‚òÖ', 'Team Data Science R&D',
        '‚ù§ An Khang Th·ªãnh V∆∞·ª£ng ‚ù§', 'Ph√∫c l·ªôc ƒë·∫ßy nh√†',
        '‚òÖ T√†i l·ªôc d·ªìi d√†o ‚òÖ', 'S·ª©c kh·ªèe d·ªìi d√†o',
        'Gia ƒë√¨nh h·∫°nh ph√∫c', '‚ù§ Xu√¢n sang ph√∫ qu√Ω ‚ù§',
        'Data Science ph√°t t√†i', 'V·∫°n s·ª± hanh th√¥ng',
        '‚òÖ Cung ch√∫c t√¢n xu√¢n ‚òÖ', 'R&D v∆∞∆°n t·∫ßm cao m·ªõi',
        'T·∫øt ƒë·∫øn xu√¢n v·ªÅ', '‚ù§ Masan th·ªãnh v∆∞·ª£ng ‚ù§',
      ],
      textSize: 1.4,
      textColor: '#ff5533',
      dustColor: 0xff4500,
      dustOpacity: 0.35,
    },
    {
      radiusInner: 14,
      radiusOuter: 19,
      tiltX: 0.07,
      yOffset: -10,
      speed: 0.09,
      direction: 1,
      particleCount: 650,
      texts: [
        '‚ú¶ NƒÉm m·ªõi v·∫°n s·ª± nh∆∞ √Ω ‚ú¶', 'Xu√¢n sang hoa n·ªü r·ªôn r√†ng',
        '‚ú¶ Team Data Science R&D ch√∫c T·∫øt an l√†nh ‚ú¶', 'Gia ƒë√¨nh sum h·ªçp ·∫•m √°p',
        '‚ú¶ M√πa xu√¢n h·∫°nh ph√∫c ‚ú¶', 'An khang th·ªãnh v∆∞·ª£ng quanh nƒÉm',
        '‚ú¶ Masan ‚Äî Data Science v∆∞∆°n xa ‚ú¶', 'L·ªôc tr·ªùi ban xu·ªëng mu√¥n nh√†',
        '‚ú¶ S·ª©c kh·ªèe b√¨nh an ‚ú¶', 'C√¥ng danh r·∫°ng r·ª° nƒÉm m·ªõi',
        '‚ú¶ ƒê√≥n xu√¢n ph√°t t√†i ‚ú¶', 'Hoa mai v√†ng khoe s·∫Øc',
        'Data Science driven ‚Äî NƒÉm m·ªõi r·ª±c r·ª°', '‚ú¶ Ch√∫c T·∫øt v·∫°n l·ªôc ‚ú¶',
        'Ni·ªÅm vui nƒÉm m·ªõi', '‚ú¶ Xu√¢n v·ªÅ t·∫øt ƒë·∫øn ‚ú¶', 'B√¨nh an m·ªói ng√†y',
        '‚ú¶ Ph√∫c l·ªôc song to√†n ‚ú¶', 'Data Science R&D ‚Äî R·∫°ng ng·ªùi 2026',
      ],
      textSize: 1.05,
      textColor: '#ffb347',
      dustColor: 0xcc3300,
      dustOpacity: 0.22,
    }
  ],

  fallingCount: 100,
  autoRotateSpeed: 0.18,

  // ƒê·ªè ƒë·∫≠m, v√†ng kim, cam ‚Äî t√¥ng ƒë√®n l·ªìng
  colors: [
    0xff0000, 0xdd0000, 0xbb0000, 0xff2200,
    0xff4400, 0xff6600, 0xffd700, 0xffaa00,
    0xee3300, 0xcc1100,
  ],
  // D·∫£i m√†u v√†ng cho khung ƒë√®n
  frameColors: [
    0xffd700, 0xffcc00, 0xffb800, 0xeeb422,
  ],
};

// ============================================================
// M∆ØA HOA MAI R∆†I
// ============================================================
(function() {
  const canvas = document.getElementById('petalCanvas');
  const ctx = canvas.getContext('2d');
  let W, H;
  function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
  resize();
  window.addEventListener('resize', resize);

  class Petal {
    constructor() { this.reset(true); }
    reset(init) {
      this.x = Math.random() * W;
      this.y = init ? Math.random() * -H : -20 - Math.random() * 80;
      this.size = 7 + Math.random() * 13;
      this.speedY = 0.4 + Math.random() * 1.3;
      this.speedX = (Math.random() - 0.5) * 0.7;
      this.rot = Math.random() * Math.PI * 2;
      this.rotSpd = (Math.random() - 0.5) * 0.035;
      this.wobbleA = 0.4 + Math.random() * 1.2;
      this.wobbleS = 0.008 + Math.random() * 0.018;
      this.wobbleP = Math.random() * Math.PI * 2;
      this.alpha = 0.45 + Math.random() * 0.5;
      const h = 38 + Math.random() * 24;
      const s = 80 + Math.random() * 20;
      const l = 52 + Math.random() * 28;
      this.color = `hsla(${h},${s}%,${l}%,${this.alpha})`;
      this.centerColor = `rgba(170,95,0,${this.alpha * 0.85})`;
      this.stamenColor = `rgba(195,115,0,${this.alpha * 0.75})`;
      this.type = Math.floor(Math.random() * 3);
      this.t = Math.random() * 1000;
    }
    update() {
      this.t++;
      this.y += this.speedY;
      this.x += this.speedX + Math.sin(this.t * this.wobbleS + this.wobbleP) * this.wobbleA;
      this.rot += this.rotSpd;
      if (this.y > H + 30 || this.x < -30 || this.x > W + 30) this.reset(false);
    }
    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rot);
      ctx.globalAlpha = this.alpha;
      if (this.type === 0) this.drawFlower();
      else if (this.type === 1) this.drawPetal();
      else this.drawBud();
      ctx.restore();
    }
    drawFlower() {
      const s = this.size, r = s * 0.45;
      for (let i = 0; i < 5; i++) {
        ctx.save();
        ctx.rotate((Math.PI * 2 / 5) * i - Math.PI / 2);
        ctx.beginPath();
        ctx.ellipse(0, -r * 0.6, r * 0.38, r * 0.6, 0, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.restore();
      }
      ctx.beginPath();
      ctx.arc(0, 0, s * 0.11, 0, Math.PI * 2);
      ctx.fillStyle = this.centerColor;
      ctx.fill();
      for (let i = 0; i < 5; i++) {
        const a = (Math.PI * 2 / 5) * i, d = s * 0.17;
        ctx.beginPath();
        ctx.arc(Math.cos(a) * d, Math.sin(a) * d, s * 0.035, 0, Math.PI * 2);
        ctx.fillStyle = this.stamenColor;
        ctx.fill();
      }
    }
    drawPetal() {
      ctx.beginPath();
      ctx.ellipse(0, 0, this.size * 0.28, this.size * 0.48, 0, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.fill();
    }
    drawBud() {
      ctx.beginPath();
      ctx.arc(0, 0, this.size * 0.18, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.fill();
    }
  }

  const petals = Array.from({ length: 75 }, () => new Petal());

  // Warm bokeh dots ‚Äî floating ambient light
  class Bokeh {
    constructor() { this.reset(true); }
    reset(init) {
      this.x = Math.random() * W;
      this.y = init ? Math.random() * H : -10;
      this.size = 2 + Math.random() * 6;
      this.speedY = 0.1 + Math.random() * 0.4;
      this.speedX = (Math.random() - 0.5) * 0.15;
      this.alpha = 0.08 + Math.random() * 0.18;
      this.pulseSpeed = 0.005 + Math.random() * 0.015;
      this.pulsePhase = Math.random() * Math.PI * 2;
      this.t = Math.random() * 1000;
      // Warm colors: gold, orange, soft red
      const colors = ['rgba(255,200,50,', 'rgba(255,150,30,', 'rgba(255,80,20,', 'rgba(255,220,100,'];
      this.colorBase = colors[Math.floor(Math.random() * colors.length)];
    }
    update() {
      this.t++;
      this.y += this.speedY;
      this.x += this.speedX + Math.sin(this.t * 0.005) * 0.15;
      if (this.y > H + 20) this.reset(false);
    }
    draw() {
      const pulse = this.alpha * (0.6 + 0.4 * Math.sin(this.t * this.pulseSpeed + this.pulsePhase));
      const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
      grad.addColorStop(0, this.colorBase + pulse + ')');
      grad.addColorStop(1, this.colorBase + '0)');
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fillStyle = grad;
      ctx.fill();
    }
  }

  const bokehs = Array.from({ length: 40 }, () => new Bokeh());

  function loop() {
    requestAnimationFrame(loop);
    ctx.clearRect(0, 0, W, H);
    for (const b of bokehs) { b.update(); b.draw(); }
    for (const p of petals) { p.update(); p.draw(); }
  }
  loop();
})();

// ============================================================
// THREE.JS SETUP
// ============================================================
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x1a0500, 0.006);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 2, 36);
camera.lookAt(0, -2, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setClearColor(0x150200, 1);
document.body.appendChild(renderer.domElement);

// ============================================================
// ƒê√àN L·ªíNG PARAMETRIC ‚Äî Lantern 3D shape
// ============================================================
function lanternProfile(t) {
  // t: 0 (bottom) ‚Üí 1 (top)
  // Returns radius at that height
  if (t < 0.08) {
    // Bottom neck ‚Äî narrow opening
    return 0.8 + (t / 0.08) * 1.2;
  }
  if (t > 0.92) {
    // Top neck ‚Äî narrow opening
    return 0.8 + ((1 - t) / 0.08) * 1.2;
  }
  // Main body ‚Äî beautiful curved profile
  const bt = (t - 0.08) / 0.84; // 0‚Üí1 within body
  // Use sin for smooth bulge, add slight rib variation
  const base = Math.sin(bt * Math.PI);
  const ribs = 1 + 0.06 * Math.sin(bt * Math.PI * 8); // subtle horizontal ribs
  return 2.0 + 4.2 * base * ribs;
}

function getLanternPoint(scale) {
  const u = Math.random() * Math.PI * 2;   // angle around
  const t = Math.random();                   // 0‚Üí1 bottom‚Üítop

  const maxR = lanternProfile(t);
  // Fill the lantern (surface + some inner glow)
  const fillMode = Math.random();
  let r;
  if (fillMode < 0.6) {
    // Surface shell ‚Äî most particles on the skin
    r = maxR * (0.92 + Math.random() * 0.08);
  } else {
    // Inner glow fill
    r = maxR * Math.pow(Math.random(), 0.6);
  }

  const x = r * Math.cos(u);
  const z = r * Math.sin(u);
  const y = (t - 0.5) * 14;  // total height ~14 units

  return new THREE.Vector3(x * scale * 0.07, y * scale * 0.07, z * scale * 0.07);
}

// Frame rings ‚Äî golden horizontal rings on the lantern
function getLanternFramePoint(scale) {
  const u = Math.random() * Math.PI * 2;
  // Pick one of the rib positions
  const ribPositions = [0.08, 0.2, 0.35, 0.5, 0.65, 0.8, 0.92];
  const t = ribPositions[Math.floor(Math.random() * ribPositions.length)];
  const maxR = lanternProfile(t) + 0.15;
  const r = maxR * (0.97 + Math.random() * 0.03);
  const x = r * Math.cos(u);
  const z = r * Math.sin(u);
  const y = (t - 0.5) * 14;
  return new THREE.Vector3(x * scale * 0.07, y * scale * 0.07, z * scale * 0.07);
}

// Vertical ribs on the lantern
function getLanternRibPoint(scale) {
  const ribCount = 10;
  const ribIndex = Math.floor(Math.random() * ribCount);
  const u = (ribIndex / ribCount) * Math.PI * 2;
  const t = 0.08 + Math.random() * 0.84; // body only
  const maxR = lanternProfile(t) + 0.1;
  const r = maxR * (0.98 + Math.random() * 0.02);
  const x = r * Math.cos(u + (Math.random() - 0.5) * 0.03);
  const z = r * Math.sin(u + (Math.random() - 0.5) * 0.03);
  const y = (t - 0.5) * 14;
  return new THREE.Vector3(x * scale * 0.07, y * scale * 0.07, z * scale * 0.07);
}

// Tassel ‚Äî hanging threads at the bottom
function getTasselPoint(scale) {
  const u = Math.random() * Math.PI * 2;
  const spreadTop = 0.6;
  const spreadBot = 1.8;
  const length = 2 + Math.random() * 4;
  const tNorm = length / 6; // 0‚Üí1
  const spread = spreadTop + tNorm * (spreadBot - spreadTop);
  const r = Math.random() * spread;
  const x = r * Math.cos(u);
  const z = r * Math.sin(u);
  const y = -7 - length; // starts below bottom of lantern

  return new THREE.Vector3(x * scale * 0.07, y * scale * 0.07, z * scale * 0.07);
}

// ============================================================
// MAIN GROUP
// ============================================================
const lanternGroup = new THREE.Group();
scene.add(lanternGroup);

// ============================================================
// LANTERN BODY PARTICLES
// ============================================================
const bodyCount = CONFIG.lanternParticles;
const bodyGeo = new THREE.BufferGeometry();
const bodyPos = new Float32Array(bodyCount * 3);
const bodyCols = new Float32Array(bodyCount * 3);
const bodySizes = new Float32Array(bodyCount);

for (let i = 0; i < bodyCount; i++) {
  let p;
  const r = Math.random();
  if (r < 0.7) {
    p = getLanternPoint(CONFIG.lanternScale);
    const color = new THREE.Color(CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)]);
    bodyCols[i*3] = color.r;
    bodyCols[i*3+1] = color.g;
    bodyCols[i*3+2] = color.b;
  } else if (r < 0.85) {
    p = getLanternFramePoint(CONFIG.lanternScale);
    const color = new THREE.Color(CONFIG.frameColors[Math.floor(Math.random() * CONFIG.frameColors.length)]);
    bodyCols[i*3] = color.r;
    bodyCols[i*3+1] = color.g;
    bodyCols[i*3+2] = color.b;
  } else {
    p = getLanternRibPoint(CONFIG.lanternScale);
    const color = new THREE.Color(CONFIG.frameColors[Math.floor(Math.random() * CONFIG.frameColors.length)]);
    bodyCols[i*3] = color.r;
    bodyCols[i*3+1] = color.g;
    bodyCols[i*3+2] = color.b;
  }
  bodyPos[i*3] = p.x;
  bodyPos[i*3+1] = p.y;
  bodyPos[i*3+2] = p.z;
  bodySizes[i] = CONFIG.particleSizeMin + Math.random() * (CONFIG.particleSizeMax - CONFIG.particleSizeMin);
}

bodyGeo.setAttribute('position', new THREE.BufferAttribute(bodyPos, 3));
bodyGeo.setAttribute('color', new THREE.BufferAttribute(bodyCols, 3));
bodyGeo.setAttribute('size', new THREE.BufferAttribute(bodySizes, 1));

const bodyMat = new THREE.ShaderMaterial({
  uniforms: {
    uTime: { value: 0 },
    uPulse: { value: 1.0 },
    uPixelRatio: { value: renderer.getPixelRatio() },
  },
  vertexShader: `
    attribute float size;
    attribute vec3 color;
    varying vec3 vColor;
    varying float vAlpha;
    uniform float uTime;
    uniform float uPulse;
    uniform float uPixelRatio;
    float hash(float n) { return fract(sin(n) * 43758.5453123); }
    void main() {
      vColor = color;
      float phase = hash(float(gl_VertexID)) * 6.2831;
      float speed = 1.2 + hash(float(gl_VertexID) + 100.0) * 2.5;
      vAlpha = 0.3 + 0.7 * (0.5 + 0.5 * sin(uTime * speed + phase));
      vec3 pos = position;
      float driftAmt = 0.06;
      pos.x += sin(uTime * (0.4 + hash(float(gl_VertexID)+1.0)) + hash(float(gl_VertexID)+2.0) * 6.28) * driftAmt;
      pos.y += cos(uTime * (0.35 + hash(float(gl_VertexID)+3.0)) + hash(float(gl_VertexID)+4.0) * 6.28) * driftAmt;
      pos.z += sin(uTime * (0.25 + hash(float(gl_VertexID)+5.0)) + hash(float(gl_VertexID)+6.0) * 6.28) * driftAmt;
      pos *= uPulse;
      vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
      gl_PointSize = size * uPixelRatio * 120.0 / -mvPosition.z;
      gl_Position = projectionMatrix * mvPosition;
    }
  `,
  fragmentShader: `
    varying vec3 vColor;
    varying float vAlpha;
    void main() {
      float d = length(gl_PointCoord - vec2(0.5));
      if (d > 0.5) discard;
      float glow = 1.0 - smoothstep(0.0, 0.5, d);
      glow = pow(glow, 1.5);
      gl_FragColor = vec4(vColor * glow * 1.6, glow * vAlpha);
    }
  `,
  transparent: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
});

lanternGroup.add(new THREE.Points(bodyGeo, bodyMat));

// ============================================================
// TASSEL PARTICLES ‚Äî Tua rua ƒë√®n l·ªìng
// ============================================================
const tasselCount = CONFIG.tasselParticles;
const tasselGeo = new THREE.BufferGeometry();
const tasselPos = new Float32Array(tasselCount * 3);
const tasselCols = new Float32Array(tasselCount * 3);
const tasselSizes = new Float32Array(tasselCount);

for (let i = 0; i < tasselCount; i++) {
  const p = getTasselPoint(CONFIG.lanternScale);
  tasselPos[i*3] = p.x;
  tasselPos[i*3+1] = p.y;
  tasselPos[i*3+2] = p.z;

  // Tassel: gold to dark red gradient
  const mix = Math.random();
  const c1 = new THREE.Color(0xffd700);
  const c2 = new THREE.Color(0xcc1100);
  const color = c1.clone().lerp(c2, mix);
  tasselCols[i*3] = color.r;
  tasselCols[i*3+1] = color.g;
  tasselCols[i*3+2] = color.b;
  tasselSizes[i] = 0.03 + Math.random() * 0.08;
}

tasselGeo.setAttribute('position', new THREE.BufferAttribute(tasselPos, 3));
tasselGeo.setAttribute('color', new THREE.BufferAttribute(tasselCols, 3));
tasselGeo.setAttribute('size', new THREE.BufferAttribute(tasselSizes, 1));

const tasselMat = new THREE.ShaderMaterial({
  uniforms: {
    uTime: { value: 0 },
    uPixelRatio: { value: renderer.getPixelRatio() },
  },
  vertexShader: `
    attribute float size;
    attribute vec3 color;
    varying vec3 vColor;
    varying float vAlpha;
    uniform float uTime;
    uniform float uPixelRatio;
    float hash(float n) { return fract(sin(n) * 43758.5453); }
    void main() {
      vColor = color;
      float phase = hash(float(gl_VertexID)) * 6.28;
      vAlpha = 0.3 + 0.5 * (0.5 + 0.5 * sin(uTime * 1.5 + phase));
      vec3 pos = position;
      // Tassel sway
      float sway = sin(uTime * 0.8 + pos.y * 0.5) * 0.12;
      pos.x += sway;
      pos.z += sway * 0.5;
      vec4 mv = modelViewMatrix * vec4(pos, 1.0);
      gl_PointSize = size * uPixelRatio * 100.0 / -mv.z;
      gl_Position = projectionMatrix * mv;
    }
  `,
  fragmentShader: `
    varying vec3 vColor;
    varying float vAlpha;
    void main() {
      float d = length(gl_PointCoord - vec2(0.5));
      if (d > 0.5) discard;
      float glow = 1.0 - smoothstep(0.0, 0.5, d);
      glow = pow(glow, 1.8);
      gl_FragColor = vec4(vColor * 1.3, glow * vAlpha);
    }
  `,
  transparent: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
});
lanternGroup.add(new THREE.Points(tasselGeo, tasselMat));

// ============================================================
// CIRCUMSTELLAR DISK ‚Äî DUST PARTICLES
// ============================================================
function createDiskDust(disk) {
  const count = disk.particleCount;
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count * 3);
  const sizes = new Float32Array(count);
  const cols = new Float32Array(count * 3);
  const baseColor = new THREE.Color(disk.dustColor);
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const r = disk.radiusInner + Math.random() * (disk.radiusOuter - disk.radiusInner);
    pos[i*3] = Math.cos(angle) * r;
    pos[i*3+1] = (Math.random() - 0.5) * 0.5;
    pos[i*3+2] = Math.sin(angle) * r;
    sizes[i] = 0.02 + Math.random() * 0.07;
    const v = 0.7 + Math.random() * 0.3;
    cols[i*3] = baseColor.r * v;
    cols[i*3+1] = baseColor.g * v;
    cols[i*3+2] = baseColor.b * v;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
  geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));
  const mat = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uOpacity: { value: disk.dustOpacity },
      uPixelRatio: { value: renderer.getPixelRatio() },
    },
    vertexShader: `
      attribute float size; attribute vec3 color;
      varying vec3 vColor; varying float vAlpha;
      uniform float uTime; uniform float uPixelRatio;
      float hash(float n){return fract(sin(n)*43758.5453);}
      void main(){
        vColor=color;
        float phase=hash(float(gl_VertexID))*6.28;
        vAlpha=0.4+0.6*(0.5+0.5*sin(uTime*(1.0+hash(float(gl_VertexID)+10.0)*2.0)+phase));
        vec4 mv=modelViewMatrix*vec4(position,1.0);
        gl_PointSize=size*uPixelRatio*100.0/-mv.z;
        gl_Position=projectionMatrix*mv;
      }
    `,
    fragmentShader: `
      varying vec3 vColor; varying float vAlpha; uniform float uOpacity;
      void main(){
        float d=length(gl_PointCoord-vec2(0.5));
        if(d>0.5)discard;
        float glow=1.0-smoothstep(0.0,0.5,d);
        glow=pow(glow,2.0);
        gl_FragColor=vec4(vColor*1.3,glow*vAlpha*uOpacity);
      }
    `,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
  });
  return new THREE.Points(geo, mat);
}

// ============================================================
// TEXT SPRITES
// ============================================================
function createTextTexture(text, fontSize, color, fontFamily) {
  const c = document.createElement('canvas');
  const ctx = c.getContext('2d');
  const scale = 6;
  ctx.font = `bold ${fontSize * scale}px ${fontFamily}`;
  const w = Math.ceil(ctx.measureText(text).width) + 40;
  const h = Math.ceil(fontSize * scale * 2);
  c.width = w; c.height = h;
  ctx.font = `bold ${fontSize * scale}px ${fontFamily}`;
  ctx.textBaseline = 'middle';
  ctx.textAlign = 'center';
  ctx.shadowColor = color;
  ctx.shadowBlur = 15 * scale;
  ctx.fillStyle = color;
  ctx.fillText(text, w/2, h/2);
  ctx.shadowBlur = 0;
  ctx.fillStyle = color;
  ctx.fillText(text, w/2, h/2);
  const tex = new THREE.CanvasTexture(c);
  tex.needsUpdate = true;
  return { texture: tex, aspect: w / h };
}

function createDiskTexts(disk) {
  const group = new THREE.Group();
  const texts = disk.texts;
  const count = texts.length;
  const step = (Math.PI * 2) / count;
  for (let i = 0; i < count; i++) {
    const { texture, aspect } = createTextTexture(
      texts[i], 36, disk.textColor, "'Dancing Script','Great Vibes',cursive"
    );
    const mat = new THREE.SpriteMaterial({
      map: texture, transparent: true,
      blending: THREE.AdditiveBlending, depthWrite: false, opacity: 0.9,
    });
    const sprite = new THREE.Sprite(mat);
    const angle = step * i;
    const r = disk.radiusInner + (disk.radiusOuter - disk.radiusInner) * 0.5;
    const rv = r + (Math.random() - 0.5) * (disk.radiusOuter - disk.radiusInner) * 0.3;
    sprite.position.set(Math.cos(angle) * rv, (Math.random() - 0.5) * 0.3, Math.sin(angle) * rv);
    const s = disk.textSize;
    sprite.scale.set(s * aspect * 0.7, s * 0.7, 1);
    group.add(sprite);
  }
  return group;
}

// ============================================================
// BUILD DISKS
// ============================================================
const diskGroups = [];
const diskDustMaterials = [];

CONFIG.disks.forEach((diskConf) => {
  const dg = new THREE.Group();
  dg.position.y = diskConf.yOffset;
  dg.rotation.x = diskConf.tiltX;

  const dust = createDiskDust(diskConf);
  dg.add(dust);
  diskDustMaterials.push(dust.material);

  dg.add(createDiskTexts(diskConf));

  const ringR = (diskConf.radiusInner + diskConf.radiusOuter) / 2;
  const tubeR = (diskConf.radiusOuter - diskConf.radiusInner) / 2;
  const torusGeo = new THREE.TorusGeometry(ringR, tubeR, 8, 80);
  const torusMat = new THREE.ShaderMaterial({
    uniforms: { uColor: { value: new THREE.Color(diskConf.dustColor) }, uTime: { value: 0 } },
    vertexShader: `
      varying vec3 vNormal; varying vec3 vPos;
      void main(){ vNormal=normalize(normalMatrix*normal); vPos=position;
      gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }
    `,
    fragmentShader: `
      uniform vec3 uColor; uniform float uTime;
      varying vec3 vNormal; varying vec3 vPos;
      void main(){
        float rim=1.0-abs(dot(vNormal,vec3(0.0,1.0,0.0)));
        rim=pow(rim,3.0);
        float shimmer=0.7+0.3*sin(vPos.x*2.0+vPos.z*2.0+uTime*1.5);
        gl_FragColor=vec4(uColor*shimmer,rim*0.05);
      }
    `,
    transparent: true, blending: THREE.AdditiveBlending,
    side: THREE.DoubleSide, depthWrite: false,
  });
  const tm = new THREE.Mesh(torusGeo, torusMat);
  tm.rotation.x = Math.PI / 2;
  dg.add(tm);

  dg.userData = { speed: diskConf.speed, direction: diskConf.direction, torusMat };
  lanternGroup.add(dg);
  diskGroups.push(dg);
});

// ============================================================
// LANTERN AMBIENT GLOW
// ============================================================
const glowGeo = new THREE.SphereGeometry(7, 32, 32);
const glowMat = new THREE.ShaderMaterial({
  uniforms: { uColor: { value: new THREE.Color(0xff2200) }, uTime: { value: 0 } },
  vertexShader: `
    varying vec3 vNormal;
    void main(){ vNormal=normalize(normalMatrix*normal);
    gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }
  `,
  fragmentShader: `
    uniform vec3 uColor; uniform float uTime; varying vec3 vNormal;
    void main(){
      float intensity=pow(0.65-dot(vNormal,vec3(0.0,0.0,1.0)),3.0);
      float pulse=0.5+0.5*sin(uTime*2.0);
      gl_FragColor=vec4(uColor,intensity*0.12*(0.8+0.2*pulse));
    }
  `,
  transparent: true, blending: THREE.AdditiveBlending,
  side: THREE.BackSide, depthWrite: false,
});
lanternGroup.add(new THREE.Mesh(glowGeo, glowMat));

// ============================================================
// BACKGROUND PARTICLES
// ============================================================
const bgCount = CONFIG.fallingCount;
const bgGeo = new THREE.BufferGeometry();
const bgPos = new Float32Array(bgCount * 3);
const bgVel = new Float32Array(bgCount);
const bgCols = new Float32Array(bgCount * 3);
const bgSizes = new Float32Array(bgCount);
for (let i = 0; i < bgCount; i++) {
  bgPos[i*3] = (Math.random() - 0.5) * 80;
  bgPos[i*3+1] = (Math.random() - 0.5) * 60;
  bgPos[i*3+2] = (Math.random() - 0.5) * 60;
  bgVel[i] = 0.01 + Math.random() * 0.025;
  const c = new THREE.Color(CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)]);
  bgCols[i*3] = c.r; bgCols[i*3+1] = c.g; bgCols[i*3+2] = c.b;
  bgSizes[i] = 0.02 + Math.random() * 0.05;
}
bgGeo.setAttribute('position', new THREE.BufferAttribute(bgPos, 3));
bgGeo.setAttribute('color', new THREE.BufferAttribute(bgCols, 3));
bgGeo.setAttribute('size', new THREE.BufferAttribute(bgSizes, 1));
const bgMat = new THREE.ShaderMaterial({
  uniforms: { uPixelRatio: { value: renderer.getPixelRatio() } },
  vertexShader: `
    attribute float size; attribute vec3 color;
    varying vec3 vColor; uniform float uPixelRatio;
    void main(){ vColor=color; vec4 mv=modelViewMatrix*vec4(position,1.0);
    gl_PointSize=size*uPixelRatio*100.0/-mv.z; gl_Position=projectionMatrix*mv; }
  `,
  fragmentShader: `
    varying vec3 vColor;
    void main(){ float d=length(gl_PointCoord-vec2(0.5));
    if(d>0.5)discard; float glow=1.0-smoothstep(0.0,0.5,d);
    gl_FragColor=vec4(vColor,glow*0.2); }
  `,
  transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
});
scene.add(new THREE.Points(bgGeo, bgMat));

// ============================================================
// INTERACTION
// ============================================================
let isDragging = false;
let previousMouse = { x: 0, y: 0 };
let targetRotX = 0.15, targetRotY = 0;
let currentRotX = 0.15, currentRotY = 0;
let autoAngle = 0, lastInteraction = 0;

function onDown(e) {
  isDragging = true;
  const p = e.touches ? e.touches[0] : e;
  previousMouse.x = p.clientX; previousMouse.y = p.clientY;
  lastInteraction = performance.now();
}
function onMove(e) {
  if (!isDragging) return;
  e.preventDefault();
  const p = e.touches ? e.touches[0] : e;
  targetRotY += (p.clientX - previousMouse.x) * 0.008;
  targetRotX += (p.clientY - previousMouse.y) * 0.006;
  targetRotX = Math.max(-Math.PI * 0.4, Math.min(Math.PI * 0.4, targetRotX));
  previousMouse.x = p.clientX; previousMouse.y = p.clientY;
  lastInteraction = performance.now();
}
function onUp() { isDragging = false; }

renderer.domElement.addEventListener('mousedown', onDown);
window.addEventListener('mousemove', onMove);
window.addEventListener('mouseup', onUp);
renderer.domElement.addEventListener('touchstart', onDown, { passive: false });
window.addEventListener('touchmove', onMove, { passive: false });
window.addEventListener('touchend', onUp);
renderer.domElement.addEventListener('wheel', (e) => {
  e.preventDefault();
  camera.position.z = Math.max(16, Math.min(55, camera.position.z + e.deltaY * 0.03));
}, { passive: false });

// ============================================================
// PULSE
// ============================================================
function getPulse(t) {
  const freq = (2 * Math.PI) / CONFIG.pulseSpeed;
  const b1 = Math.max(0, Math.sin(t * freq));
  const b2 = Math.max(0, Math.sin(t * freq - 0.6)) * 0.6;
  return 1 + Math.max(b1, b2) * CONFIG.pulseMagnitude;
}

// ============================================================
// ANIMATION
// ============================================================
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const elapsed = clock.getElapsedTime();
  const dt = clock.getDelta();

  const since = (performance.now() - lastInteraction) / 1000;
  if (since > 2.5) {
    autoAngle += CONFIG.autoRotateSpeed * dt;
    targetRotY = autoAngle;
  } else {
    autoAngle = targetRotY;
  }

  currentRotX += (targetRotX - currentRotX) * 0.06;
  currentRotY += (targetRotY - currentRotY) * 0.06;
  lanternGroup.rotation.x = currentRotX;
  lanternGroup.rotation.y = currentRotY;

  bodyMat.uniforms.uTime.value = elapsed;
  bodyMat.uniforms.uPulse.value = getPulse(elapsed);
  tasselMat.uniforms.uTime.value = elapsed;
  glowMat.uniforms.uTime.value = elapsed;

  diskGroups.forEach(dg => {
    dg.rotation.y += dg.userData.speed * dg.userData.direction * dt;
    dg.userData.torusMat.uniforms.uTime.value = elapsed;
  });
  diskDustMaterials.forEach(m => { m.uniforms.uTime.value = elapsed; });

  const positions = bgGeo.attributes.position.array;
  for (let i = 0; i < bgCount; i++) {
    positions[i*3+1] -= bgVel[i];
    if (positions[i*3+1] < -30) {
      positions[i*3+1] = 30;
      positions[i*3] = (Math.random() - 0.5) * 80;
      positions[i*3+2] = (Math.random() - 0.5) * 60;
    }
  }
  bgGeo.attributes.position.needsUpdate = true;

  renderer.render(scene, camera);
}

// ============================================================
// RESIZE
// ============================================================
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  const pr = Math.min(window.devicePixelRatio, 2);
  renderer.setPixelRatio(pr);
  bodyMat.uniforms.uPixelRatio.value = pr;
  tasselMat.uniforms.uPixelRatio.value = pr;
  bgMat.uniforms.uPixelRatio.value = pr;
  diskDustMaterials.forEach(m => { m.uniforms.uPixelRatio.value = pr; });
});

animate();

// ============================================================
// MUSIC ‚Äî Auto-play
// ============================================================
const bgMusic = document.getElementById('bgMusic');
const musicControl = document.getElementById('musicControl');
let isPlaying = false;

function tryAutoplay() {
  bgMusic.play().then(() => {
    isPlaying = true;
    musicControl.classList.add('playing');
    musicControl.textContent = 'üéµ';
  }).catch(() => {
    isPlaying = false;
    musicControl.classList.remove('playing');
    musicControl.textContent = 'üîá';
  });
}
tryAutoplay();

let hasInteracted = false;
function onFirstInteraction() {
  if (!hasInteracted && !isPlaying) {
    hasInteracted = true;
    bgMusic.play().then(() => {
      isPlaying = true;
      musicControl.classList.add('playing');
      musicControl.textContent = 'üéµ';
    }).catch(() => {});
  }
}
document.addEventListener('click', onFirstInteraction, { once: false });
document.addEventListener('touchstart', onFirstInteraction, { once: false });
document.addEventListener('keydown', onFirstInteraction, { once: false });

musicControl.addEventListener('click', (e) => {
  e.stopPropagation();
  hasInteracted = true;
  if (isPlaying) {
    bgMusic.pause();
    musicControl.textContent = 'üîá';
    musicControl.classList.remove('playing');
  } else {
    bgMusic.play();
    musicControl.textContent = 'üéµ';
    musicControl.classList.add('playing');
  }
  isPlaying = !isPlaying;
});
</script>
</body>
</html>
