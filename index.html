<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>üíï Tr√°i Tim 3D Valentine</title>
<link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Great+Vibes&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #000;
    cursor: grab;
    font-family: 'Dancing Script', cursive;
  }
  body:active { cursor: grabbing; }
  canvas { display: block; }
  #hint {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    color: rgba(255,150,190,0.7);
    font-family: 'Dancing Script', cursive;
    font-size: 16px;
    pointer-events: none;
    animation: fadeHint 5s ease-in-out forwards;
    text-shadow: 0 0 20px rgba(255,100,160,0.5);
    white-space: nowrap;
  }
  @keyframes fadeHint {
    0% { opacity: 0; transform: translateX(-50%) translateY(10px); }
    15% { opacity: 1; transform: translateX(-50%) translateY(0); }
    75% { opacity: 1; }
    100% { opacity: 0; }
  }
  #musicControl {
    position: fixed;
    top: 24px;
    right: 24px;
    width: 50px;
    height: 50px;
    background: rgba(255, 100, 160, 0.2);
    border: 2px solid rgba(255, 150, 190, 0.5);
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    z-index: 1000;
  }
  #musicControl:hover {
    background: rgba(255, 100, 160, 0.4);
    border-color: rgba(255, 150, 190, 0.8);
    transform: scale(1.1);
  }
  #musicControl.playing {
    animation: pulse 2s ease-in-out infinite;
  }
  @keyframes pulse {
    0%, 100% { box-shadow: 0 0 20px rgba(255, 100, 160, 0.3); }
    50% { box-shadow: 0 0 30px rgba(255, 100, 160, 0.6); }
  }
</style>
</head>
<body>
<div id="hint">‚ú® K√©o chu·ªôt ƒë·ªÉ xoay tr√°i tim ‚ú®</div>
<div id="musicControl" class="playing" title="Click ƒë·ªÉ b·∫≠t/t·∫Øt nh·∫°c">üéµ</div>
<audio id="bgMusic" loop>
  <source src="I Do.mp3" type="audio/mpeg">
</audio>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================================
// CONFIG
// ============================================================
const CONFIG = {
  heartParticles: 10000,
  heartScale: 10,
  particleSizeMin: 0.06,
  particleSizeMax: 0.22,
  pulseSpeed: 1.2,
  pulseMagnitude: 0.04,

  // 3 Circumstellar Disks
  disks: [
    {
      // Inner disk ‚Äî closest to heart
      radiusInner: 8,
      radiusOuter: 13,
      tiltX: 0.15,
      yOffset: -6.5,
      speed: 0.25,
      direction: 1,
      particleCount: 300,
      texts: [
        '‚ô° Y√™u em ‚ô°', 'M√£i b√™n nhau', '‚ô° My Love ‚ô°', 'H·∫°nh ph√∫c',
        '‚ô° Forever ‚ô°', 'Be mine', 'Tr·ªçn ƒë·ªùi', '‚ô° Anh y√™u em ‚ô°',
        'Nh·ªõ em', 'T√¨nh y√™u', '‚ô° Sweetheart ‚ô°', 'Y√™u th∆∞∆°ng',
      ],
      textSize: 1.4,
      textColor: '#ffb6d5',
      dustColor: 0xff69b4,
      dustOpacity: 0.5,
    },
    {
      // Middle disk
      radiusInner: 11.5,
      radiusOuter: 15,
      tiltX: 0.12,
      yOffset: -7.5,
      speed: 0.16,
      direction: -1,
      particleCount: 500,
      texts: [
        '‚òÖ Happy Valentine ‚òÖ', 'Anh y√™u em nhi·ªÅu l·∫Øm', '‚ù§ Together forever ‚ù§',
        'Tr·ªçn ƒë·ªùi b√™n nhau', '‚òÖ T√¨nh y√™u vƒ©nh c·ª≠u ‚òÖ', 'Mu√¥n ƒë·ªùi kh√¥ng ƒë·ªïi',
        'Em l√† t·∫•t c·∫£', '‚ù§ I love you ‚ù§', 'M√£i m√£i y√™u em',
        'H·∫°nh ph√∫c b√™n nhau', '‚òÖ Ng·ªçt ng√†o ‚òÖ', 'You & Me forever',
        'Tr√°i tim anh', '‚ù§ N·∫Øm tay nhau ‚ù§', 'ƒê√¥i ta m√£i m√£i',
      ],
      textSize: 1.5,
      textColor: '#ff82b4',
      dustColor: 0xda70d6,
      dustOpacity: 0.35,
    },
    {
      // Outer disk ‚Äî largest ring
      radiusInner: 15.5,
      radiusOuter: 20,
      tiltX: 0.08,
      yOffset: -8.5,
      speed: 0.1,
      direction: 1,
      particleCount: 700,
      texts: [
        '‚ú¶ Em l√† √°nh s√°ng c·ªßa ƒë·ªùi anh ‚ú¶', 'Y√™u th∆∞∆°ng kh√¥ng bao gi·ªù phai',
        '‚ú¶ Nh·ªõ nhung ‚ú¶', 'Tr√°i tim n√†y thu·ªôc v·ªÅ em', '‚ú¶ M·ªông m∆° ‚ú¶',
        'Hy v·ªçng ng√†y mai b√™n nhau', '‚ú¶ H·∫°nh ph√∫c l√† c√≥ em ‚ú¶',
        'M√£i m√£i v√† m√£i m√£i', '‚ú¶ Sao tr·ªùi d·∫´n l·ªëi ‚ú¶',
        'T√¨nh y√™u ƒë√≠ch th·ª±c', '‚ú¶ Vƒ©nh h·∫±ng ‚ú¶', 'C√πng nhau ƒëi h·∫øt cu·ªôc ƒë·ªùi',
        'Con tim ch·ªâ thu·ªôc em', '‚ú¶ L·ªùi h·ª©a trƒÉm nƒÉm ‚ú¶',
        'Ng√†n nƒÉm v·∫´n y√™u', '‚ú¶ Gi·∫•c m∆° c√≥ em ‚ú¶', 'B√™n nhau tr·ªçn ki·∫øp',
        '‚ú¶ √Ånh trƒÉng t√¨nh y√™u ‚ú¶', 'ƒê·∫πp nh·∫•t l√† em',
      ],
      textSize: 1.1,
      textColor: '#c87ab8',
      dustColor: 0xc71585,
      dustOpacity: 0.25,
    }
  ],

  fallingCount: 120,
  autoRotateSpeed: 0.15,

  colors: [
    0xff69b4, 0xff1493, 0xda70d6, 0xff6ec7,
    0xf778a1, 0xe75480, 0xff85a2, 0xc71585,
    0xff5ba7, 0xdb7093
  ],
};

// ============================================================
// THREE.JS SETUP
// ============================================================
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.008);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 5, 38);
camera.lookAt(0, -2, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setClearColor(0x000000, 1);
document.body.appendChild(renderer.domElement);

// ============================================================
// HEART PARAMETRIC (3D)
// ============================================================
function heartX(t) { return 16 * Math.pow(Math.sin(t), 3); }
function heartY(t) { return 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t); }

function getHeartPoint(scale) {
  const t = Math.random() * Math.PI * 2;
  const fill = Math.pow(Math.random(), 0.5);
  const x = heartX(t) * fill;
  const y = heartY(t) * fill;
  const dist = Math.sqrt(x*x + y*y);
  const maxDist = 17;
  const zRange = Math.sqrt(Math.max(0, 1 - (dist/maxDist) * (dist/maxDist))) * 3.5;
  const z = (Math.random() - 0.5) * 2 * zRange;
  return new THREE.Vector3(x * scale * 0.065, y * scale * 0.065, z * scale * 0.065);
}

// ============================================================
// MAIN GROUP
// ============================================================
const heartGroup = new THREE.Group();
scene.add(heartGroup);

// ============================================================
// HEART PARTICLES
// ============================================================
const heartGeometry = new THREE.BufferGeometry();
const heartPositions = new Float32Array(CONFIG.heartParticles * 3);
const heartColors = new Float32Array(CONFIG.heartParticles * 3);
const heartSizes = new Float32Array(CONFIG.heartParticles);

for (let i = 0; i < CONFIG.heartParticles; i++) {
  const p = getHeartPoint(CONFIG.heartScale);
  heartPositions[i*3] = p.x;
  heartPositions[i*3+1] = p.y;
  heartPositions[i*3+2] = p.z;

  const color = new THREE.Color(CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)]);
  heartColors[i*3] = color.r;
  heartColors[i*3+1] = color.g;
  heartColors[i*3+2] = color.b;

  heartSizes[i] = CONFIG.particleSizeMin + Math.random() * (CONFIG.particleSizeMax - CONFIG.particleSizeMin);
}

heartGeometry.setAttribute('position', new THREE.BufferAttribute(heartPositions, 3));
heartGeometry.setAttribute('color', new THREE.BufferAttribute(heartColors, 3));
heartGeometry.setAttribute('size', new THREE.BufferAttribute(heartSizes, 1));

const heartMaterial = new THREE.ShaderMaterial({
  uniforms: {
    uTime: { value: 0 },
    uPulse: { value: 1.0 },
    uPixelRatio: { value: renderer.getPixelRatio() },
  },
  vertexShader: `
    attribute float size;
    attribute vec3 color;
    varying vec3 vColor;
    varying float vAlpha;
    uniform float uTime;
    uniform float uPulse;
    uniform float uPixelRatio;
    float hash(float n) { return fract(sin(n) * 43758.5453123); }
    void main() {
      vColor = color;
      float phase = hash(float(gl_VertexID)) * 6.2831;
      float speed = 1.5 + hash(float(gl_VertexID) + 100.0) * 3.0;
      vAlpha = 0.35 + 0.65 * (0.5 + 0.5 * sin(uTime * speed + phase));
      vec3 pos = position;
      float driftAmt = 0.08;
      pos.x += sin(uTime * (0.5 + hash(float(gl_VertexID)+1.0)) + hash(float(gl_VertexID)+2.0) * 6.28) * driftAmt;
      pos.y += cos(uTime * (0.4 + hash(float(gl_VertexID)+3.0)) + hash(float(gl_VertexID)+4.0) * 6.28) * driftAmt;
      pos.z += sin(uTime * (0.3 + hash(float(gl_VertexID)+5.0)) + hash(float(gl_VertexID)+6.0) * 6.28) * driftAmt;
      pos *= uPulse;
      vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
      gl_PointSize = size * uPixelRatio * 120.0 / -mvPosition.z;
      gl_Position = projectionMatrix * mvPosition;
    }
  `,
  fragmentShader: `
    varying vec3 vColor;
    varying float vAlpha;
    void main() {
      float d = length(gl_PointCoord - vec2(0.5));
      if (d > 0.5) discard;
      float glow = 1.0 - smoothstep(0.0, 0.5, d);
      glow = pow(glow, 1.5);
      gl_FragColor = vec4(vColor * glow * 1.5, glow * vAlpha);
    }
  `,
  transparent: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
});

const heartPoints = new THREE.Points(heartGeometry, heartMaterial);
heartGroup.add(heartPoints);

// ============================================================
// CIRCUMSTELLAR DISK ‚Äî DUST PARTICLES
// ============================================================
function createDiskDust(disk) {
  const count = disk.particleCount;
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count * 3);
  const sizes = new Float32Array(count);
  const cols = new Float32Array(count * 3);
  const baseColor = new THREE.Color(disk.dustColor);

  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const r = disk.radiusInner + Math.random() * (disk.radiusOuter - disk.radiusInner);
    // Flatten into disk shape with slight vertical scatter
    const scatter = (Math.random() - 0.5) * 0.6;
    pos[i*3]     = Math.cos(angle) * r;
    pos[i*3+1]   = scatter;
    pos[i*3+2]   = Math.sin(angle) * r;

    sizes[i] = 0.02 + Math.random() * 0.08;

    // Color variation
    const variation = 0.7 + Math.random() * 0.3;
    cols[i*3]   = baseColor.r * variation;
    cols[i*3+1] = baseColor.g * variation;
    cols[i*3+2] = baseColor.b * variation;
  }

  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
  geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));

  const mat = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uOpacity: { value: disk.dustOpacity },
      uPixelRatio: { value: renderer.getPixelRatio() },
    },
    vertexShader: `
      attribute float size;
      attribute vec3 color;
      varying vec3 vColor;
      varying float vAlpha;
      uniform float uTime;
      uniform float uPixelRatio;
      float hash(float n) { return fract(sin(n) * 43758.5453); }
      void main() {
        vColor = color;
        float phase = hash(float(gl_VertexID)) * 6.28;
        vAlpha = 0.4 + 0.6 * (0.5 + 0.5 * sin(uTime * (1.0 + hash(float(gl_VertexID)+10.0)*2.0) + phase));
        vec4 mv = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * uPixelRatio * 100.0 / -mv.z;
        gl_Position = projectionMatrix * mv;
      }
    `,
    fragmentShader: `
      varying vec3 vColor;
      varying float vAlpha;
      uniform float uOpacity;
      void main() {
        float d = length(gl_PointCoord - vec2(0.5));
        if (d > 0.5) discard;
        float glow = 1.0 - smoothstep(0.0, 0.5, d);
        glow = pow(glow, 2.0);
        gl_FragColor = vec4(vColor * 1.3, glow * vAlpha * uOpacity);
      }
    `,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
  });

  return new THREE.Points(geo, mat);
}

// ============================================================
// CIRCUMSTELLAR DISK ‚Äî TEXT SPRITES
// ============================================================
function createTextTexture(text, fontSize, color, fontFamily) {
  const c = document.createElement('canvas');
  const ctx = c.getContext('2d');
  const scale = 6; // Higher res
  ctx.font = `bold ${fontSize * scale}px ${fontFamily}`;
  const metrics = ctx.measureText(text);
  const w = Math.ceil(metrics.width) + 40;
  const h = Math.ceil(fontSize * scale * 2);
  c.width = w;
  c.height = h;

  // Glow effect
  ctx.font = `bold ${fontSize * scale}px ${fontFamily}`;
  ctx.textBaseline = 'middle';
  ctx.textAlign = 'center';

  // Outer glow
  ctx.shadowColor = color;
  ctx.shadowBlur = 15 * scale;
  ctx.fillStyle = color;
  ctx.fillText(text, w/2, h/2);

  // Crisp text on top
  ctx.shadowBlur = 0;
  ctx.fillStyle = color;
  ctx.fillText(text, w/2, h/2);

  const tex = new THREE.CanvasTexture(c);
  tex.needsUpdate = true;
  return { texture: tex, aspect: w / h };
}

function createDiskTexts(disk) {
  const group = new THREE.Group();
  const texts = disk.texts;
  const count = texts.length;
  const angleStep = (Math.PI * 2) / count;

  for (let i = 0; i < count; i++) {
    const { texture, aspect } = createTextTexture(
      texts[i], 36, disk.textColor, "'Dancing Script', 'Great Vibes', cursive"
    );

    const spriteMat = new THREE.SpriteMaterial({
      map: texture,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      opacity: 0.92,
    });
    const sprite = new THREE.Sprite(spriteMat);

    const angle = angleStep * i;
    const r = disk.radiusInner + (disk.radiusOuter - disk.radiusInner) * 0.5;
    // Slight radius variation for natural feel
    const rVariation = r + (Math.random() - 0.5) * (disk.radiusOuter - disk.radiusInner) * 0.35;

    sprite.position.set(
      Math.cos(angle) * rVariation,
      (Math.random() - 0.5) * 0.3,
      Math.sin(angle) * rVariation
    );

    const s = disk.textSize;
    sprite.scale.set(s * aspect * 0.7, s * 0.7, 1);
    group.add(sprite);
  }

  return group;
}

// ============================================================
// BUILD ALL 3 DISKS
// ============================================================
const diskGroups = [];
const diskDustMaterials = [];

CONFIG.disks.forEach((diskConf, idx) => {
  const diskGroup = new THREE.Group();
  diskGroup.position.y = diskConf.yOffset;
  diskGroup.rotation.x = diskConf.tiltX;

  // Dust particles
  const dust = createDiskDust(diskConf);
  diskGroup.add(dust);
  diskDustMaterials.push(dust.material);

  // Text sprites
  const textGroup = createDiskTexts(diskConf);
  diskGroup.add(textGroup);

  // Glow ring (torus for rim light)
  const ringRadius = (diskConf.radiusInner + diskConf.radiusOuter) / 2;
  const tubeRadius = (diskConf.radiusOuter - diskConf.radiusInner) / 2;
  const torusGeo = new THREE.TorusGeometry(ringRadius, tubeRadius, 8, 80);
  const torusMat = new THREE.ShaderMaterial({
    uniforms: {
      uColor: { value: new THREE.Color(diskConf.dustColor) },
      uTime: { value: 0 },
    },
    vertexShader: `
      varying vec3 vNormal;
      varying vec3 vPos;
      void main() {
        vNormal = normalize(normalMatrix * normal);
        vPos = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 uColor;
      uniform float uTime;
      varying vec3 vNormal;
      varying vec3 vPos;
      void main() {
        float rim = 1.0 - abs(dot(vNormal, vec3(0.0, 1.0, 0.0)));
        rim = pow(rim, 3.0);
        float shimmer = 0.7 + 0.3 * sin(vPos.x * 2.0 + vPos.z * 2.0 + uTime * 1.5);
        gl_FragColor = vec4(uColor * shimmer, rim * 0.06);
      }
    `,
    transparent: true,
    blending: THREE.AdditiveBlending,
    side: THREE.DoubleSide,
    depthWrite: false,
  });
  const torusMesh = new THREE.Mesh(torusGeo, torusMat);
  torusMesh.rotation.x = Math.PI / 2;
  diskGroup.add(torusMesh);

  diskGroup.userData = {
    speed: diskConf.speed,
    direction: diskConf.direction,
    torusMat: torusMat,
  };

  heartGroup.add(diskGroup);
  diskGroups.push(diskGroup);
});

// ============================================================
// HEART AMBIENT GLOW
// ============================================================
const glowGeo = new THREE.SphereGeometry(9, 32, 32);
const glowMat = new THREE.ShaderMaterial({
  uniforms: {
    uColor: { value: new THREE.Color(0xff1493) },
    uTime: { value: 0 },
  },
  vertexShader: `
    varying vec3 vNormal;
    void main() {
      vNormal = normalize(normalMatrix * normal);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 uColor;
    uniform float uTime;
    varying vec3 vNormal;
    void main() {
      float intensity = pow(0.65 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 3.0);
      float pulse = 0.5 + 0.5 * sin(uTime * 2.0);
      gl_FragColor = vec4(uColor, intensity * 0.1 * (0.8 + 0.2 * pulse));
    }
  `,
  transparent: true,
  blending: THREE.AdditiveBlending,
  side: THREE.BackSide,
  depthWrite: false,
});
heartGroup.add(new THREE.Mesh(glowGeo, glowMat));

// ============================================================
// BACKGROUND FALLING PARTICLES
// ============================================================
const bgCount = CONFIG.fallingCount;
const bgGeo = new THREE.BufferGeometry();
const bgPos = new Float32Array(bgCount * 3);
const bgVel = new Float32Array(bgCount);
const bgCols = new Float32Array(bgCount * 3);
const bgSizes = new Float32Array(bgCount);

for (let i = 0; i < bgCount; i++) {
  bgPos[i*3]   = (Math.random() - 0.5) * 80;
  bgPos[i*3+1] = (Math.random() - 0.5) * 60;
  bgPos[i*3+2] = (Math.random() - 0.5) * 60;
  bgVel[i] = 0.01 + Math.random() * 0.03;
  const c = new THREE.Color(CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)]);
  bgCols[i*3] = c.r; bgCols[i*3+1] = c.g; bgCols[i*3+2] = c.b;
  bgSizes[i] = 0.02 + Math.random() * 0.06;
}

bgGeo.setAttribute('position', new THREE.BufferAttribute(bgPos, 3));
bgGeo.setAttribute('color', new THREE.BufferAttribute(bgCols, 3));
bgGeo.setAttribute('size', new THREE.BufferAttribute(bgSizes, 1));

const bgMat = new THREE.ShaderMaterial({
  uniforms: { uPixelRatio: { value: renderer.getPixelRatio() } },
  vertexShader: `
    attribute float size;
    attribute vec3 color;
    varying vec3 vColor;
    uniform float uPixelRatio;
    void main() {
      vColor = color;
      vec4 mv = modelViewMatrix * vec4(position, 1.0);
      gl_PointSize = size * uPixelRatio * 100.0 / -mv.z;
      gl_Position = projectionMatrix * mv;
    }
  `,
  fragmentShader: `
    varying vec3 vColor;
    void main() {
      float d = length(gl_PointCoord - vec2(0.5));
      if (d > 0.5) discard;
      float glow = 1.0 - smoothstep(0.0, 0.5, d);
      gl_FragColor = vec4(vColor, glow * 0.25);
    }
  `,
  transparent: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
});
scene.add(new THREE.Points(bgGeo, bgMat));

// ============================================================
// MOUSE / TOUCH INTERACTION
// ============================================================
let isDragging = false;
let previousMouse = { x: 0, y: 0 };
let targetRotationX = 0.25; // slight downward look default
let targetRotationY = 0;
let currentRotationX = 0.25;
let currentRotationY = 0;
let autoRotateAngle = 0;
let lastInteraction = 0;

function onPointerDown(e) {
  isDragging = true;
  const p = e.touches ? e.touches[0] : e;
  previousMouse.x = p.clientX;
  previousMouse.y = p.clientY;
  lastInteraction = performance.now();
}
function onPointerMove(e) {
  if (!isDragging) return;
  e.preventDefault();
  const p = e.touches ? e.touches[0] : e;
  const dx = p.clientX - previousMouse.x;
  const dy = p.clientY - previousMouse.y;
  targetRotationY += dx * 0.008;
  targetRotationX += dy * 0.006;
  targetRotationX = Math.max(-Math.PI * 0.45, Math.min(Math.PI * 0.45, targetRotationX));
  previousMouse.x = p.clientX;
  previousMouse.y = p.clientY;
  lastInteraction = performance.now();
}
function onPointerUp() { isDragging = false; }

renderer.domElement.addEventListener('mousedown', onPointerDown);
window.addEventListener('mousemove', onPointerMove);
window.addEventListener('mouseup', onPointerUp);
renderer.domElement.addEventListener('touchstart', onPointerDown, { passive: false });
window.addEventListener('touchmove', onPointerMove, { passive: false });
window.addEventListener('touchend', onPointerUp);

renderer.domElement.addEventListener('wheel', (e) => {
  e.preventDefault();
  camera.position.z = Math.max(18, Math.min(60, camera.position.z + e.deltaY * 0.03));
}, { passive: false });

// ============================================================
// PULSE
// ============================================================
function getPulse(t) {
  const freq = (2 * Math.PI) / CONFIG.pulseSpeed;
  const b1 = Math.max(0, Math.sin(t * freq));
  const b2 = Math.max(0, Math.sin(t * freq - 0.6)) * 0.6;
  return 1 + Math.max(b1, b2) * CONFIG.pulseMagnitude;
}

// ============================================================
// ANIMATION LOOP
// ============================================================
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const elapsed = clock.getElapsedTime();
  const dt = clock.getDelta();

  // Auto-rotate
  const timeSinceInteraction = (performance.now() - lastInteraction) / 1000;
  if (timeSinceInteraction > 2.5) {
    autoRotateAngle += CONFIG.autoRotateSpeed * dt;
    targetRotationY = autoRotateAngle;
  } else {
    autoRotateAngle = targetRotationY;
  }

  // Smooth rotation
  currentRotationX += (targetRotationX - currentRotationX) * 0.06;
  currentRotationY += (targetRotationY - currentRotationY) * 0.06;
  heartGroup.rotation.x = currentRotationX;
  heartGroup.rotation.y = currentRotationY;

  // Heart uniforms
  heartMaterial.uniforms.uTime.value = elapsed;
  heartMaterial.uniforms.uPulse.value = getPulse(elapsed);
  glowMat.uniforms.uTime.value = elapsed;

  // Rotate disks
  diskGroups.forEach(dg => {
    dg.rotation.y += dg.userData.speed * dg.userData.direction * dt;
    dg.userData.torusMat.uniforms.uTime.value = elapsed;
  });

  // Update dust uniforms
  diskDustMaterials.forEach(m => {
    m.uniforms.uTime.value = elapsed;
  });

  // Falling bg particles
  const positions = bgGeo.attributes.position.array;
  for (let i = 0; i < bgCount; i++) {
    positions[i*3+1] -= bgVel[i];
    if (positions[i*3+1] < -30) {
      positions[i*3+1] = 30;
      positions[i*3] = (Math.random() - 0.5) * 80;
      positions[i*3+2] = (Math.random() - 0.5) * 60;
    }
  }
  bgGeo.attributes.position.needsUpdate = true;

  renderer.render(scene, camera);
}

// ============================================================
// RESIZE
// ============================================================
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  const pr = Math.min(window.devicePixelRatio, 2);
  renderer.setPixelRatio(pr);
  heartMaterial.uniforms.uPixelRatio.value = pr;
  bgMat.uniforms.uPixelRatio.value = pr;
  diskDustMaterials.forEach(m => { m.uniforms.uPixelRatio.value = pr; });
});

animate();

// ============================================================
// MUSIC CONTROL
// ============================================================
const bgMusic = document.getElementById('bgMusic');
const musicControl = document.getElementById('musicControl');
let isPlaying = false;

// Try to autoplay when user first interacts
let hasInteracted = false;
function tryAutoplay() {
  if (!hasInteracted) {
    hasInteracted = true;
    bgMusic.play().then(() => {
      isPlaying = true;
      musicControl.classList.add('playing');
    }).catch(() => {
      // Autoplay blocked, user needs to click
      isPlaying = false;
      musicControl.classList.remove('playing');
    });
  }
}

document.addEventListener('click', tryAutoplay, { once: true });
document.addEventListener('touchstart', tryAutoplay, { once: true });

musicControl.addEventListener('click', (e) => {
  e.stopPropagation();
  if (isPlaying) {
    bgMusic.pause();
    musicControl.textContent = 'üîá';
    musicControl.classList.remove('playing');
  } else {
    bgMusic.play();
    musicControl.textContent = 'üéµ';
    musicControl.classList.add('playing');
  }
  isPlaying = !isPlaying;
});
</script>
</body>
</html>
